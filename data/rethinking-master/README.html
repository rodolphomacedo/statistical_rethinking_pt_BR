
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rethinking &#8212; Statistical Rethinking</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Statistical Rethinking</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../capa.html">
   Estatistica Bayesiana
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro_pt-BR.html">
   Intro - Estatística Bayesiana (🇧🇷)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro_en.html">
   Intro - Bayesian Statistics (🇺🇸)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../parte_1.html">
   1- Introdução
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../parte_2.html">
   2 - Engenharia de Golems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../parte_3.html">
   3- Modelos Geocêntricos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../parte_4.html">
   4 - Funções Wiggly
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../parte_5.html">
   5 - Muitas variáveis e os waffles espúrios
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/data/rethinking-master/README.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/rodolphomacedo/statistical_rethinking_pt_BR"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/rodolphomacedo/statistical_rethinking_pt_BR/issues/new?title=Issue%20on%20page%20%2Fdata/rethinking-master/README.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   rethinking
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quick-installation">
   Quick Installation
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quadratic-approximation-with-quap">
   Quadratic Approximation with
   <code class="docutils literal notranslate">
    <span class="pre">
     quap
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hamiltonian-monte-carlo-with-ulam-and-map2stan">
   Hamiltonian Monte Carlo with
   <code class="docutils literal notranslate">
    <span class="pre">
     ulam
    </span>
   </code>
   (and
   <code class="docutils literal notranslate">
    <span class="pre">
     map2stan
    </span>
   </code>
   )
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#posterior-prediction">
     Posterior prediction
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multilevel-model-formulas">
     Multilevel model formulas
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#log-likelihood-calculations-for-waic-and-loocv">
     log-likelihood calculations for WAIC and LOOCV
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conditional-statements-custom-distributions-and-mixture-models">
     Conditional statements, custom distributions, and mixture models
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#continuous-missing-data-imputation">
     Continuous missing data imputation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gaussian-processes">
     Gaussian processes
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#within-chain-multithreading">
     Within-chain multithreading
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#work-in-progress">
     Work in progress
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#map2stan-syntax-and-features">
   <code class="docutils literal notranslate">
    <span class="pre">
     map2stan
    </span>
   </code>
   syntax and features
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#non-centered-parameterization">
     Non-centered parameterization
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#semi-automated-bayesian-imputation">
     Semi-automated Bayesian imputation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#semi-automated-marginalization-for-binary-discrete-missing-values">
     Semi-automated marginalization for binary discrete missing values
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gaussian-process">
     Gaussian process
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#information-criteria">
     Information criteria
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-issues-with-1st-edition-of-statistical-rethinking">
   Code issues with 1st edition of Statistical Rethinking
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#r-code-7-10">
     R code 7.10
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#r-code-7-17">
     R code 7.17
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="rethinking">
<h1>rethinking<a class="headerlink" href="#rethinking" title="Permalink to this headline">¶</a></h1>
<p>This R package accompanies a course and book on Bayesian data analysis: McElreath 2020. Statistical Rethinking, 2nd edition, CRC Press. If you are using it with the first edition of the book, please see the notes at the bottom of this file.</p>
<p>It contains tools for conducting both quick quadratic approximation of the posterior distribution as well as Hamiltonian Monte Carlo (through RStan or cmdstanr - <a class="reference external" href="http://mc-stan.org">mc-stan.org</a>). Many packages do this. The signature difference of this package is that it forces the user to specify the model as a list of explicit distributional assumptions. This is more tedious than typical formula-based tools, but it is also much more flexible and powerful and—most important—useful for teaching and learning. When students have to write out every detail of the model, they actually learn the model.</p>
<p>For example, a simple Gaussian model could be specified with this list of formulas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dexp</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The first formula in the list is the probability of the outcome (likelihood); the second is the prior for <code class="docutils literal notranslate"><span class="pre">mu</span></code>; the third is the prior for <code class="docutils literal notranslate"><span class="pre">sigma</span></code>.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="quick-installation">
<h1>Quick Installation<a class="headerlink" href="#quick-installation" title="Permalink to this headline">¶</a></h1>
<p>You can find a manual with expanded installation and usage instructions here: <code class="docutils literal notranslate"><span class="pre">http://xcelab.net/rm/software/</span></code></p>
<p>Here’s the brief verison.</p>
<p>You’ll need to install <code class="docutils literal notranslate"><span class="pre">rstan</span></code> first. Go to <code class="docutils literal notranslate"><span class="pre">http://mc-stan.org</span></code> and follow the instructions for your platform. The biggest challenge is getting a C++ compiler configured to work with your installation of R. The instructions at <code class="docutils literal notranslate"><span class="pre">https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started</span></code> are quite thorough. Obey them, and you’ll likely succeed.</p>
<p>There are some advantages to accessing Stan through <code class="docutils literal notranslate"><span class="pre">cmdstanr</span></code> rather than rstan. These advantages include faster updates and therefore quicker access to new features. If you want to access Stan using the <code class="docutils literal notranslate"><span class="pre">cmdstanr</span></code> package instead, then you may install that as well with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">devtools</span><span class="p">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">&quot;stan-dev/cmdstanr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you haven’t installed cmdstan previously, you will also need to do that with <code class="docutils literal notranslate"><span class="pre">cmdstanr::install_cmdstan()</span></code>. Then you need to add <code class="docutils literal notranslate"><span class="pre">cmdstan=TRUE</span></code> to any <code class="docutils literal notranslate"><span class="pre">ulam</span></code> code to use cmdstan instead of rstan. To use cmdstan as the default interface, do <code class="docutils literal notranslate"><span class="pre">set_ulam_cmdstan(TRUE)</span></code>.</p>
<p>Once rstan and cmdstan are installed (almost there), then you can install <code class="docutils literal notranslate"><span class="pre">rethinking</span></code> from within R using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">install</span><span class="o">.</span><span class="n">packages</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="s2">&quot;coda&quot;</span><span class="p">,</span><span class="s2">&quot;mvtnorm&quot;</span><span class="p">,</span><span class="s2">&quot;devtools&quot;</span><span class="p">,</span><span class="s2">&quot;loo&quot;</span><span class="p">,</span><span class="s2">&quot;dagitty&quot;</span><span class="p">))</span>
<span class="n">devtools</span><span class="p">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">&quot;rmcelreath/rethinking&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If there are any problems, they likely arise when trying to install <code class="docutils literal notranslate"><span class="pre">rstan</span></code>, so the <code class="docutils literal notranslate"><span class="pre">rethinking</span></code> package has little to do with it. See the manual linked above for some hints about getting <code class="docutils literal notranslate"><span class="pre">rstan</span></code> installed. But always consult the RStan section of the website at <code class="docutils literal notranslate"><span class="pre">mc-stan.org</span></code> for the latest information on RStan.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="quadratic-approximation-with-quap">
<h1>Quadratic Approximation with <code class="docutils literal notranslate"><span class="pre">quap</span></code><a class="headerlink" href="#quadratic-approximation-with-quap" title="Permalink to this headline">¶</a></h1>
<p>Almost any ordinary generalized linear model can be specified with <code class="docutils literal notranslate"><span class="pre">quap</span></code>. To use quadratic approximation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">library</span><span class="p">(</span><span class="n">rethinking</span><span class="p">)</span>

<span class="n">f</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dexp</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
<span class="p">)</span>

<span class="n">fit</span> <span class="o">&lt;-</span> <span class="n">quap</span><span class="p">(</span> 
    <span class="n">f</span> <span class="p">,</span> 
    <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">c</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">,</span> 
    <span class="n">start</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The object <code class="docutils literal notranslate"><span class="pre">fit</span></code> holds the result. For a summary of marginal posterior distributions, use <code class="docutils literal notranslate"><span class="pre">summary(fit)</span></code> or <code class="docutils literal notranslate"><span class="pre">precis(fit)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">mean</span>   <span class="n">sd</span>  <span class="mf">5.5</span><span class="o">%</span> <span class="mf">94.5</span><span class="o">%</span>
<span class="n">mu</span>    <span class="mf">0.00</span> <span class="mf">0.59</span> <span class="o">-</span><span class="mf">0.95</span>  <span class="mf">0.95</span>
<span class="n">sigma</span> <span class="mf">0.84</span> <span class="mf">0.33</span>  <span class="mf">0.31</span>  <span class="mf">1.36</span>
</pre></div>
</div>
<p>It also supports vectorized parameters, which is convenient for categories. See examples <code class="docutils literal notranslate"><span class="pre">?quap</span></code>.</p>
<p>In the first edition of the textbook, this function was called <code class="docutils literal notranslate"><span class="pre">map</span></code>. It can still be used with that alias. It was renamed, because the name <code class="docutils literal notranslate"><span class="pre">map</span></code> was misleading. This function produces quadratic approximations of the posterior distribution, not just maximum a posteriori (MAP) estimates.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="hamiltonian-monte-carlo-with-ulam-and-map2stan">
<h1>Hamiltonian Monte Carlo with <code class="docutils literal notranslate"><span class="pre">ulam</span></code> (and <code class="docutils literal notranslate"><span class="pre">map2stan</span></code>)<a class="headerlink" href="#hamiltonian-monte-carlo-with-ulam-and-map2stan" title="Permalink to this headline">¶</a></h1>
<p>The same formula list can be compiled into a Stan (<a class="reference external" href="http://mc-stan.org">mc-stan.org</a>) model using one of two tools: <code class="docutils literal notranslate"><span class="pre">ulam</span></code> or <code class="docutils literal notranslate"><span class="pre">map2stan</span></code>. For simple models, they are identical. <code class="docutils literal notranslate"><span class="pre">ulam</span></code> is the newer tool that allows for much more flexibility, including explicit variable types and custom distributions. <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> is the original tool from the first edition of the package and textbook. Going forward, new features will be added to <code class="docutils literal notranslate"><span class="pre">ulam</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ulam</span></code> is named after Stanisław Ulam, who was one of the parents of the Monte Carlo method and is the namesake of the Stan project as well. It is pronounced something like [OO-lahm], not like [YOU-lamm].</p>
<p>Both tools take the same kind of input as <code class="docutils literal notranslate"><span class="pre">quap</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit_stan</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span> <span class="n">f</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">c</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>The chain runs automatically, provided <code class="docutils literal notranslate"><span class="pre">rstan</span></code> is installed. Chain diagnostics are displayed in the <code class="docutils literal notranslate"><span class="pre">precis(fit_stan)</span></code> output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="n">mean</span>   <span class="n">sd</span>  <span class="mf">5.5</span><span class="o">%</span> <span class="mf">94.5</span><span class="o">%</span> <span class="n">n_eff</span> <span class="n">Rhat</span>
<span class="n">sigma</span> <span class="mf">1.45</span> <span class="mf">0.72</span>  <span class="mf">0.67</span>  <span class="mf">2.84</span>   <span class="mi">145</span>    <span class="mi">1</span>
<span class="n">mu</span>    <span class="mf">0.12</span> <span class="mf">1.04</span> <span class="o">-</span><span class="mf">1.46</span>  <span class="mf">1.59</span>   <span class="mi">163</span>    <span class="mi">1</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">ulam</span></code> models, <code class="docutils literal notranslate"><span class="pre">plot</span></code> displays the same information as <code class="docutils literal notranslate"><span class="pre">precis</span></code> and <code class="docutils literal notranslate"><span class="pre">traceplot</span></code> displays the chains.</p>
<p><code class="docutils literal notranslate"><span class="pre">extract.samples</span></code> returns samples in a list. <code class="docutils literal notranslate"><span class="pre">extract.prior</span></code> samples from the prior and returns the samples in a list as well.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stanfit</span></code> object itself is in the <code class="docutils literal notranslate"><span class="pre">&#64;stanfit</span></code> slot. Anything you’d do with a Stan model can be done with that slot directly.</p>
<p>The Stan code can be accessed by using <code class="docutils literal notranslate"><span class="pre">stancode(fit_stan)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">{</span>
    <span class="n">real</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">parameters</span><span class="p">{</span>
    <span class="n">real</span><span class="o">&lt;</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">sigma</span><span class="p">;</span>
    <span class="n">real</span> <span class="n">mu</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">model</span><span class="p">{</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">exponential</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">mu</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ulam</span></code> doesn’t care about R distribution names. You can instead use Stan-style names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit_stan</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">y</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
        <span class="n">mu</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
        <span class="n">sigma</span> <span class="o">~</span> <span class="n">exponential</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">),</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">c</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<div class="section" id="posterior-prediction">
<h2>Posterior prediction<a class="headerlink" href="#posterior-prediction" title="Permalink to this headline">¶</a></h2>
<p>All <code class="docutils literal notranslate"><span class="pre">quap</span></code>, <code class="docutils literal notranslate"><span class="pre">ulam</span></code>, and <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> objects can be post-processed to produce posterior predictive distributions.</p>
<p><code class="docutils literal notranslate"><span class="pre">link</span></code> is used to compute values of any linear models over samples from the posterior distribution.</p>
<p><code class="docutils literal notranslate"><span class="pre">sim</span></code> is used to simulate posterior predictive distributions, simulating outcomes over samples from the posterior distribution of parameters. <code class="docutils literal notranslate"><span class="pre">sim</span></code> can also be used to simulate prior predictives.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">?link</span></code> and <code class="docutils literal notranslate"><span class="pre">?sim</span></code> for details.</p>
<p><code class="docutils literal notranslate"><span class="pre">postcheck</span></code> automatically computes posterior predictive (retrodictive?) checks. It merely uses <code class="docutils literal notranslate"><span class="pre">link</span></code> and <code class="docutils literal notranslate"><span class="pre">sim</span></code>.</p>
</div>
<div class="section" id="multilevel-model-formulas">
<h2>Multilevel model formulas<a class="headerlink" href="#multilevel-model-formulas" title="Permalink to this headline">¶</a></h2>
<p>While <code class="docutils literal notranslate"><span class="pre">quap</span></code> is limited to fixed effects models for the most part, <code class="docutils literal notranslate"><span class="pre">ulam</span></code> can specify multilevel models, even quite complex ones. For example, a simple varying intercepts model looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># prep data
data( UCBadmit )
UCBadmit$male &lt;- as.integer(UCBadmit$applicant.gender==&quot;male&quot;)
UCBadmit$dept &lt;- rep( 1:6 , each=2 )
UCBadmit$applicant.gender &lt;- NULL

# varying intercepts model
m_glmm1 &lt;- ulam(
    alist(
        admit ~ binomial(applications,p),
        logit(p) &lt;- a[dept] + b*male,
        a[dept] ~ normal( abar , sigma ),
        abar ~ normal( 0 , 4 ),
        sigma ~ half_normal(0,1),
        b ~ normal(0,1)
    ), data=UCBadmit )
</pre></div>
</div>
<p>The analogous varying slopes model is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_glmm2</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span><span class="n">applications</span><span class="p">,</span><span class="n">p</span><span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span><span class="o">*</span><span class="n">male</span><span class="p">,</span>
        <span class="n">c</span><span class="p">(</span> <span class="n">a</span> <span class="p">,</span> <span class="n">b</span> <span class="p">)[</span><span class="n">dept</span><span class="p">]</span> <span class="o">~</span> <span class="n">multi_normal</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="n">abar</span><span class="p">,</span><span class="n">bbar</span><span class="p">)</span> <span class="p">,</span> <span class="n">Rho</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
        <span class="n">abar</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">4</span> <span class="p">),</span>
        <span class="n">bbar</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">sigma</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">Rho</span> <span class="o">~</span> <span class="n">lkjcorr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">)</span>
</pre></div>
</div>
<p>Another way to express the varying slopes model is with a vector of varying effects. This is made possible by using an explicit vector declaration inside the formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_glmm3</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span><span class="n">applications</span><span class="p">,</span><span class="n">p</span><span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">male</span><span class="p">,</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">~</span> <span class="n">multi_normal</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="n">abar</span><span class="p">,</span><span class="n">bbar</span><span class="p">)</span> <span class="p">,</span> <span class="n">Rho</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
        <span class="n">abar</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">4</span> <span class="p">),</span>
        <span class="n">bbar</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">sigma</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">Rho</span> <span class="o">~</span> <span class="n">lkjcorr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">)</span>
</pre></div>
</div>
<p>That <code class="docutils literal notranslate"><span class="pre">vector[2]:v[dept]</span></code> means “declare a vector of length two for each unique dept”. To access the elements of these vectors, the linear model uses multiple indexes inside the brackets: <code class="docutils literal notranslate"><span class="pre">[dept,1]</span></code>.</p>
<p>This strategy can be taken one step further and the means can be declared as a vector as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_glmm4</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span><span class="n">applications</span><span class="p">,</span><span class="n">p</span><span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">male</span><span class="p">,</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">~</span> <span class="n">multi_normal</span><span class="p">(</span> <span class="n">v_mu</span> <span class="p">,</span> <span class="n">Rho</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">v_mu</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">sigma</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">Rho</span> <span class="o">~</span> <span class="n">lkjcorr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">)</span>
</pre></div>
</div>
<p>And a completely non-centered parameterization can be coded directly as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_glmm5</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span><span class="n">applications</span><span class="p">,</span><span class="n">p</span><span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v_mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">v_mu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">male</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">[</span><span class="n">dept</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span> <span class="n">v</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="p">(</span><span class="n">diag_pre_multiply</span><span class="p">(</span> <span class="n">sigma</span> <span class="p">,</span> <span class="n">L_Rho</span> <span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="p">),</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">dept</span><span class="p">]:</span> <span class="n">z</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">v_mu</span><span class="p">[[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">v_mu</span><span class="p">[[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">sigma</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">cholesky_factor_corr</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">L_Rho</span> <span class="o">~</span> <span class="n">lkj_corr_cholesky</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">)</span>
</pre></div>
</div>
<p>In the above, the varying effects matrix <code class="docutils literal notranslate"><span class="pre">v</span></code> is constructed from a matrix of z-scores <code class="docutils literal notranslate"><span class="pre">z</span></code> and a covariance structure contained in <code class="docutils literal notranslate"><span class="pre">sigma</span></code> and a Cholesky factor <code class="docutils literal notranslate"><span class="pre">L_Rho</span></code>. Note the double-bracket notation <code class="docutils literal notranslate"><span class="pre">v_mu[[1]]</span></code> allowing distinct priors for each index of a vector.</p>
</div>
<div class="section" id="log-likelihood-calculations-for-waic-and-loocv">
<h2>log-likelihood calculations for WAIC and LOOCV<a class="headerlink" href="#log-likelihood-calculations-for-waic-and-loocv" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ulam</span></code> can optionally return pointwise log-likelihood values. These are needed for computing WAIC and PSIS-LOO. The <code class="docutils literal notranslate"><span class="pre">log_lik</span></code> argument toggles this on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_glmm1</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span><span class="n">applications</span><span class="p">,</span><span class="n">p</span><span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">male</span><span class="p">,</span>
        <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="n">abar</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
        <span class="n">abar</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">4</span> <span class="p">),</span>
        <span class="n">sigma</span> <span class="o">~</span> <span class="n">half_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">b</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">),</span> <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">,</span> <span class="n">log_lik</span><span class="o">=</span><span class="n">TRUE</span> <span class="p">)</span>
<span class="n">WAIC</span><span class="p">(</span><span class="n">m_glmm1</span><span class="p">)</span>
</pre></div>
</div>
<p>The additional code has been added to the generated quantities block of the Stan model (see this with <code class="docutils literal notranslate"><span class="pre">stancode(m_glmm1)</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">generated</span> <span class="n">quantities</span><span class="p">{</span>
    <span class="n">vector</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="n">log_lik</span><span class="p">;</span>
    <span class="n">vector</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">:</span><span class="mi">12</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">male</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">:</span><span class="mi">12</span> <span class="p">)</span> <span class="n">log_lik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">binomial_lpmf</span><span class="p">(</span> <span class="n">admit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">applications</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="conditional-statements-custom-distributions-and-mixture-models">
<h2>Conditional statements, custom distributions, and mixture models<a class="headerlink" href="#conditional-statements-custom-distributions-and-mixture-models" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ulam</span></code> also supports if-then statements and custom distribution assignments. These are useful for coding mixture models, such as zero-inflated Poisson and discrete missing value models.</p>
<p>Here’s an example zero-inflated Poisson model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># zero-inflated poisson</span>
<span class="c1"># gen data first - example from text</span>
<span class="n">prob_drink</span> <span class="o">&lt;-</span> <span class="mf">0.2</span> <span class="c1"># 20% of days</span>
<span class="n">rate_work</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="c1"># average 1 manuscript per day</span>
<span class="n">N</span> <span class="o">&lt;-</span> <span class="mi">365</span>
<span class="n">drink</span> <span class="o">&lt;-</span> <span class="n">rbinom</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">prob_drink</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="k">as</span><span class="o">.</span><span class="n">integer</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">drink</span><span class="p">)</span><span class="o">*</span><span class="n">rpois</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="n">rate_work</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span> <span class="n">N</span> <span class="p">)</span> <span class="c1"># dummy covariate</span>

<span class="c1"># now ulam code</span>
<span class="n">m_zip</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">y</span><span class="o">|</span><span class="n">y</span><span class="o">==</span><span class="mi">0</span> <span class="o">~</span> <span class="n">custom</span><span class="p">(</span> <span class="n">log_mix</span><span class="p">(</span> <span class="n">p</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">poisson_lpmf</span><span class="p">(</span><span class="mi">0</span><span class="o">|</span><span class="k">lambda</span><span class="p">)</span> <span class="p">)</span> <span class="p">),</span>
        <span class="n">y</span><span class="o">|</span><span class="n">y</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">~</span> <span class="n">custom</span><span class="p">(</span> <span class="n">log1m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">poisson_lpmf</span><span class="p">(</span><span class="n">y</span><span class="o">|</span><span class="k">lambda</span><span class="p">)</span> <span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ap</span><span class="p">,</span>
        <span class="n">log</span><span class="p">(</span><span class="k">lambda</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">al</span> <span class="o">+</span> <span class="n">bl</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
        <span class="n">ap</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">al</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">bl</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The Stan code corresponding to the first two lines in the formula above is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">:</span><span class="mi">365</span> <span class="p">)</span> 
    <span class="k">if</span> <span class="p">(</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">target</span> <span class="o">+=</span> <span class="n">log1m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">poisson_lpmf</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="k">lambda</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">:</span><span class="mi">365</span> <span class="p">)</span> 
    <span class="k">if</span> <span class="p">(</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">target</span> <span class="o">+=</span> <span class="n">log_mix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">poisson_lpmf</span><span class="p">(</span><span class="mi">0</span> <span class="o">|</span> <span class="k">lambda</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</pre></div>
</div>
<p>What <code class="docutils literal notranslate"><span class="pre">custom</span></code> does is define custom <code class="docutils literal notranslate"><span class="pre">target</span></code> updates. And the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator makes the line conditional. Note that <code class="docutils literal notranslate"><span class="pre">log1m</span></code>, <code class="docutils literal notranslate"><span class="pre">log_mix</span></code>, and <code class="docutils literal notranslate"><span class="pre">poisson_lpmf</span></code> are Stan functions.</p>
<p>The same <code class="docutils literal notranslate"><span class="pre">custom</span></code> distribution approach allows for marginalization over discrete missing values. Let’s introduce some missing values in the <code class="docutils literal notranslate"><span class="pre">UCBadmit</span></code> data from earlier.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>UCBadmit$male2 &lt;- UCBadmit$male
UCBadmit$male2[1:2] &lt;- (-1) # missingness code
UCBadmit$male2 &lt;- as.integer(UCBadmit$male2)
</pre></div>
</div>
<p>Now the model needs to detect when <code class="docutils literal notranslate"><span class="pre">male2</span></code> is missing (-1) and then compute a mixture over the unknown state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_mix</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">admit</span><span class="o">|</span><span class="n">male2</span><span class="o">==-</span><span class="mi">1</span> <span class="o">~</span> <span class="n">custom</span><span class="p">(</span> <span class="n">log_mix</span><span class="p">(</span> 
            <span class="n">phi_male</span> <span class="p">,</span> 
            <span class="n">binomial_lpmf</span><span class="p">(</span><span class="n">admit</span><span class="o">|</span><span class="n">applications</span><span class="p">,</span><span class="n">p_m1</span><span class="p">)</span> <span class="p">,</span> 
            <span class="n">binomial_lpmf</span><span class="p">(</span><span class="n">admit</span><span class="o">|</span><span class="n">applications</span><span class="p">,</span><span class="n">p_m0</span><span class="p">)</span> <span class="p">)</span> <span class="p">),</span>
        <span class="n">admit</span><span class="o">|</span><span class="n">male2</span><span class="o">&gt;-</span><span class="mi">1</span> <span class="o">~</span> <span class="n">binomial</span><span class="p">(</span> <span class="n">applications</span> <span class="p">,</span> <span class="n">p</span> <span class="p">),</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">male2</span><span class="p">,</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p_m1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">logit</span><span class="p">(</span><span class="n">p_m0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">male2</span><span class="o">|</span><span class="n">male2</span><span class="o">&gt;-</span><span class="mi">1</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="p">(</span> <span class="n">phi_male</span> <span class="p">),</span>
        <span class="n">phi_male</span> <span class="o">~</span> <span class="n">beta</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">a</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">b</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">data</span><span class="o">=</span><span class="n">UCBadmit</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note the addition of <code class="docutils literal notranslate"><span class="pre">phi_male</span></code> to average over the unknown state.</p>
</div>
<div class="section" id="continuous-missing-data-imputation">
<h2>Continuous missing data imputation<a class="headerlink" href="#continuous-missing-data-imputation" title="Permalink to this headline">¶</a></h2>
<p>In principle, imputation of missing real-valued data is easy: Just replace each missing value with a parameter. In practice, this involves a bunch of annoying bookkeeping. <code class="docutils literal notranslate"><span class="pre">ulam</span></code> has a macro named <code class="docutils literal notranslate"><span class="pre">merge_missing</span></code> to simplify this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>UCBadmit$x &lt;- rnorm(12)
UCBadmit$x[1:2] &lt;- NA
m_miss &lt;- ulam(
    alist(
        admit ~ binomial(applications,p),
        logit(p) &lt;- a + b*male + bx*x_merge,
        x_merge ~ normal( 0 , 1 ),
        x_merge &lt;- merge_missing( x , x_impute ),
        a ~ normal(0,4),
        b ~ normal(0,1),
        bx ~ normal(0,1)
    ),
    data=UCBadmit )
</pre></div>
</div>
<p>What <code class="docutils literal notranslate"><span class="pre">merge_missing</span></code> does is find the <code class="docutils literal notranslate"><span class="pre">NA</span></code> values in <code class="docutils literal notranslate"><span class="pre">x</span></code> (whichever symbol is the first argument), build a vector of parameters called <code class="docutils literal notranslate"><span class="pre">x_impute</span></code> (whatever you name the second argument) of the right length, and piece together a vector <code class="docutils literal notranslate"><span class="pre">x_merge</span></code> that contains both, in the right places. You can then assign a prior to this vector and use it in linear models as usual.</p>
<p>The merging is done as the Stan model runs, using a custom function block. See the Stan code <code class="docutils literal notranslate"><span class="pre">stancode(m_miss)</span></code> for all the lovely details.</p>
<p><code class="docutils literal notranslate"><span class="pre">merge</span> <span class="pre">missing</span></code> is an example of a macro, which is a way for <code class="docutils literal notranslate"><span class="pre">ulam</span></code> to use function names to trigger special compilation. In this case, <code class="docutils literal notranslate"><span class="pre">merge_missing</span></code> both inserts a function in the Stan model and builds the necessary index to locate the missing values during run time. Macros will get full documentation later, once the system is finalized.</p>
</div>
<div class="section" id="gaussian-processes">
<h2>Gaussian processes<a class="headerlink" href="#gaussian-processes" title="Permalink to this headline">¶</a></h2>
<p>A simple Gaussian process, like the Oceanic islands example in Chapter 13 of the book, is done as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>data(Kline2)
d &lt;- Kline2
data(islandsDistMatrix)
d$society &lt;- 1:10
dat &lt;- list(
    y=d$total_tools,
    society=d$society,
    log_pop = log(d$population),
    Dmat=islandsDistMatrix
)

m_GP1 &lt;- ulam(
    alist(
        y ~ poisson( mu ),
        log(mu) &lt;- a + aj[society] + b*log_pop,
        a ~ normal(0,10),
        b ~ normal(0,1),
        vector[10]: aj ~ multi_normal( 0 , SIGMA ),
        matrix[10,10]: SIGMA &lt;- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
        etasq ~ exponential(1),
        rhosq ~ exponential(1)
    ),
    data=dat )
</pre></div>
</div>
<p>This is just an ordinary varying intercepts model, but all 10 intercepts are drawn from a single Gaussian distribution. The covariance matrix <code class="docutils literal notranslate"><span class="pre">SIGMA</span></code> is defined in the usual L2-norm. Again, <code class="docutils literal notranslate"><span class="pre">cov_GPL2</span></code> is a macro that inserts a function in the Stan code to compute the covariance matrix as the model runs.</p>
<p>Fancier Gaussian processes require a different parameterization. And these can be built as well. Here’s an example using 151 primate species and a phylogenetic distance matrix. First, prepare the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>data(Primates301)
data(Primates301_distance_matrix)
d &lt;- Primates301
d$name &lt;- as.character(d$name)
dstan &lt;- d[ complete.cases( d$social_learning, d$research_effort , d$body , d$brain ) , ]
# prune distance matrix to spp in dstan
spp_obs &lt;- dstan$name
y &lt;- Primates301_distance_matrix
y2 &lt;- y[ spp_obs , spp_obs ]
# scale distances
y3 &lt;- y2/max(y2)
</pre></div>
</div>
<p>Now the model, which is a non-centered L2-norm Gaussian process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>m_GP2 &lt;- ulam(
    alist(
        social_learning ~ poisson( lambda ),
        log(lambda) &lt;- a + g[spp_id] + b_ef*log_research_effort + b_body*log_body + b_eq*log_brain,
        a ~ normal(0,1),
        vector[N_spp]: g &lt;&lt;- L_SIGMA * eta,
        vector[N_spp]: eta ~ normal( 0 , 1 ),
        matrix[N_spp,N_spp]: L_SIGMA &lt;&lt;- cholesky_decompose( SIGMA ),
        matrix[N_spp,N_spp]: SIGMA &lt;- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
        b_body ~ normal(0,1),
        b_eq ~ normal(0,1),
        b_ef ~ normal(1,1),
        etasq ~ exponential(1),
        rhosq ~ exponential(1)
    ),
    data=list(
        N_spp = nrow(dstan),
        social_learning = dstan$social_learning,
        spp_id = 1:nrow(dstan),
        log_research_effort = log(dstan$research_effort),
        log_body = log(dstan$body),
        log_brain = log(dstan$brain),
        Dmat = y3
    ) , 
    control=list(max_treedepth=15,adapt_delta=0.95) ,
    sample=FALSE )
</pre></div>
</div>
<p>This model does not sample quickly, so I’ve set <code class="docutils literal notranslate"><span class="pre">sample=FALSE</span></code>. You can still inspect the Stan code with <code class="docutils literal notranslate"><span class="pre">stancode(m_GP2)</span></code>.</p>
<p>Note that the covariance <code class="docutils literal notranslate"><span class="pre">SIGMA</span></code> is built the same way as before, but then we immediately decompose it to a Cholesky factor and build the varying intercepts <code class="docutils literal notranslate"><span class="pre">g</span></code> by matrix multiplication. The <code class="docutils literal notranslate"><span class="pre">&lt;&lt;-</span></code> operator tells <code class="docutils literal notranslate"><span class="pre">ulam</span></code> not to loop, but to do a direct assignment. So <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">&lt;&lt;-</span> <span class="pre">L_SIGMA</span> <span class="pre">*</span> <span class="pre">eta</span></code> does the right linear algebra.</p>
</div>
<div class="section" id="within-chain-multithreading">
<h2>Within-chain multithreading<a class="headerlink" href="#within-chain-multithreading" title="Permalink to this headline">¶</a></h2>
<p>Using <code class="docutils literal notranslate"><span class="pre">cmdstanr</span></code> instead of <code class="docutils literal notranslate"><span class="pre">rstan</span></code> is currently the only way to use within-chain multithreading with <code class="docutils literal notranslate"><span class="pre">rethinking</span></code>. It also tends to compile models faster and is more intelligent about when models need to be re-compiled, so using <code class="docutils literal notranslate"><span class="pre">cmdstanr</span></code> is recommended, even if you don’t want multithreading.</p>
<p>If you want <code class="docutils literal notranslate"><span class="pre">ulam</span></code> to access Stan using the <code class="docutils literal notranslate"><span class="pre">cmdstanr</span></code> package, then you may install that as well with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">devtools</span><span class="p">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">&quot;stan-dev/cmdstanr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you haven’t installed cmdstan previously, you will also need to do that with <code class="docutils literal notranslate"><span class="pre">install_cmdstan()</span></code>.</p>
<p>Then you need to add <code class="docutils literal notranslate"><span class="pre">cmdstan=TRUE</span></code> to the <code class="docutils literal notranslate"><span class="pre">ulam</span></code> code. The <code class="docutils literal notranslate"><span class="pre">threads</span></code> argument controls the number of threads per chain. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&lt;-</span> <span class="mf">1e4</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">m</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rpois</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="n">rbinom</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">m</span> <span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">inv_logit</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
<span class="n">dat</span> <span class="o">&lt;-</span> <span class="nb">list</span><span class="p">(</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span> <span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span> <span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span> <span class="p">)</span>
<span class="c1"># two threads</span>
<span class="n">m1</span> <span class="o">&lt;-</span> <span class="n">ulam</span><span class="p">(</span>
    <span class="n">alist</span><span class="p">(</span>
        <span class="n">y</span> <span class="o">~</span> <span class="n">binomial_logit</span><span class="p">(</span> <span class="n">m</span> <span class="p">,</span> <span class="n">logit_p</span> <span class="p">),</span>
        <span class="n">logit_p</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
        <span class="n">a</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5</span><span class="p">),</span>
        <span class="n">b</span> <span class="o">~</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">dat</span> <span class="p">,</span> 
    <span class="n">cmdstan</span><span class="o">=</span><span class="n">TRUE</span> <span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">2</span> <span class="p">,</span> <span class="n">refresh</span><span class="o">=</span><span class="mi">1000</span> <span class="p">)</span>
</pre></div>
</div>
<p>There are models that cannot be automaticaly multithreaded this way, because of the complexity of the code. In those cases, you can write the code directly in Stan. See <a class="reference external" href="https://mc-stan.org/users/documentation/case-studies/reduce_sum_tutorial.html">this guide</a>. Writing multithreaded models direct in Stan can also be more efficient, since you can make detailed choices about which variables to pass and which pieces of the model to multithread.</p>
</div>
<div class="section" id="work-in-progress">
<h2>Work in progress<a class="headerlink" href="#work-in-progress" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ulam</span></code> is still in development, but mostly feature complete. It will remain primarily a teaching tool, exposing the statistical details of the model while hiding some of the programming details necessary in Stan.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="map2stan-syntax-and-features">
<h1><code class="docutils literal notranslate"><span class="pre">map2stan</span></code> syntax and features<a class="headerlink" href="#map2stan-syntax-and-features" title="Permalink to this headline">¶</a></h1>
<p>The older <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> function makes stronger assumtions about the formulas it will see. This allows is to provide some additional automation and it has some special syntax as a result. <code class="docutils literal notranslate"><span class="pre">ulam</span></code> in contrast supports such features through its macros library.</p>
<div class="section" id="non-centered-parameterization">
<h2>Non-centered parameterization<a class="headerlink" href="#non-centered-parameterization" title="Permalink to this headline">¶</a></h2>
<p>Here is a non-centered parameterization that moves the scale parameters in the varying effects prior to the linear model, which is often more efficient for sampling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f4u</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">zaj</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">*</span><span class="n">sigma_group</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> 
         <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">zbj</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">*</span><span class="n">sigma_group</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
    <span class="n">c</span><span class="p">(</span><span class="n">zaj</span><span class="p">,</span><span class="n">zbj</span><span class="p">)[</span><span class="n">group</span><span class="p">]</span> <span class="o">~</span> <span class="n">dmvnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">Rho_group</span> <span class="p">),</span>
    <span class="n">a</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">b</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma_group</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">Rho_group</span> <span class="o">~</span> <span class="n">dlkjcorr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Chapter 13 of the book provides a lot more detail on this issue.</p>
<p>We can take this strategy one step further and remove the correlation matrix, <code class="docutils literal notranslate"><span class="pre">Rho_group</span></code>, from the prior as well.  <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> facilitates this form via the <code class="docutils literal notranslate"><span class="pre">dmvnormNC</span></code> density, which uses an internal Cholesky decomposition of the correlation matrix to build the varying effects. Here is the previous varying slopes model, now with the non-centered notation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f4nc</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">aj</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">bj</span><span class="p">[</span><span class="n">group</span><span class="p">])</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
    <span class="n">c</span><span class="p">(</span><span class="n">aj</span><span class="p">,</span><span class="n">bj</span><span class="p">)[</span><span class="n">group</span><span class="p">]</span> <span class="o">~</span> <span class="n">dmvnormNC</span><span class="p">(</span> <span class="n">sigma_group</span> <span class="p">,</span> <span class="n">Rho_group</span> <span class="p">),</span>
    <span class="n">a</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">b</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma_group</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">Rho_group</span> <span class="o">~</span> <span class="n">dlkjcorr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Internally, a Cholesky factor <code class="docutils literal notranslate"><span class="pre">L_Rho_group</span></code> is used to perform sampling. It will appear in the returned samples, in addition to <code class="docutils literal notranslate"><span class="pre">Rho_group</span></code>, which is constructed from it.</p>
</div>
<div class="section" id="semi-automated-bayesian-imputation">
<h2>Semi-automated Bayesian imputation<a class="headerlink" href="#semi-automated-bayesian-imputation" title="Permalink to this headline">¶</a></h2>
<p>It is possible to code simple Bayesian imputations. For example, let’s simulate a simple regression with missing predictor values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&lt;-</span> <span class="mi">100</span>
<span class="n">N_miss</span> <span class="o">&lt;-</span> <span class="mi">10</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span> <span class="n">N</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
<span class="n">x</span><span class="p">[</span> <span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">N_miss</span><span class="p">)</span> <span class="p">]</span> <span class="o">&lt;-</span> <span class="n">NA</span>
</pre></div>
</div>
<p>That removes 10 <code class="docutils literal notranslate"><span class="pre">x</span></code> values. Then the <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> formula list just defines a distribution for <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f5</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
    <span class="n">x</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu_x</span><span class="p">,</span> <span class="n">sigma_x</span> <span class="p">),</span>
    <span class="n">a</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">100</span> <span class="p">),</span>
    <span class="n">b</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span>  <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">mu_x</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">100</span> <span class="p">),</span>
    <span class="n">sigma_x</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">m5</span> <span class="o">&lt;-</span> <span class="n">map2stan</span><span class="p">(</span> <span class="n">f5</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>What <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> does is notice the missing values, see the distribution assigned to the variable with the missing values, build the Stan code that uses a mix of observed and estimated <code class="docutils literal notranslate"><span class="pre">x</span></code> values in the regression. See the <code class="docutils literal notranslate"><span class="pre">stancode(m5)</span></code> for details of the implementation.</p>
</div>
<div class="section" id="semi-automated-marginalization-for-binary-discrete-missing-values">
<h2>Semi-automated marginalization for binary discrete missing values<a class="headerlink" href="#semi-automated-marginalization-for-binary-discrete-missing-values" title="Permalink to this headline">¶</a></h2>
<p>Binary (0/1) variables with missing values present a special obstacle, because Stan cannot sample discrete parameters. So instead of imputing binary missing values, <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> can average (marginalize) over them. As in the above case, when <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> detects missing values in a predictor variable, it will try to find a distribution for the variable containing them. If this variable is binary (0/1), then it will construct a mixture model in which each term is the log-likelihood conditional on the variables taking a particular combination of 0/1 values.</p>
<p>Following the example in the previous section, we can simulate missingness in a binary predictor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&lt;-</span> <span class="mi">100</span>
<span class="n">N_miss</span> <span class="o">&lt;-</span> <span class="mi">10</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="n">rbinom</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span> <span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
<span class="n">x</span><span class="p">[</span> <span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">N_miss</span><span class="p">)</span> <span class="p">]</span> <span class="o">&lt;-</span> <span class="n">NA</span>
</pre></div>
</div>
<p>The model definition is analogous to the previous, but also requires some care in specifying constraints for the hyperparameters that define the distribution for <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f6</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
    <span class="n">x</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="p">(</span> <span class="n">phi</span> <span class="p">),</span>
    <span class="n">a</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">100</span> <span class="p">),</span>
    <span class="n">b</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span>  <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">phi</span> <span class="o">~</span> <span class="n">beta</span><span class="p">(</span> <span class="mi">1</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">m6</span> <span class="o">&lt;-</span> <span class="n">map2stan</span><span class="p">(</span> <span class="n">f6</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="s2">&quot;lower=0,upper=1&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The algorithm works, in theory, for any number of binary predictors with missing values. For example, with two predictors, each with missingness:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&lt;-</span> <span class="mi">100</span>
<span class="n">N_miss</span> <span class="o">&lt;-</span> <span class="mi">10</span>
<span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">rbinom</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span> <span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span> <span class="p">)</span>
<span class="n">x2</span> <span class="o">&lt;-</span> <span class="n">rbinom</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span> <span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span> <span class="n">N</span> <span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span>  <span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
<span class="n">x1</span><span class="p">[</span> <span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">N_miss</span><span class="p">)</span> <span class="p">]</span> <span class="o">&lt;-</span> <span class="n">NA</span>
<span class="n">x2</span><span class="p">[</span> <span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">N_miss</span><span class="p">)</span> <span class="p">]</span> <span class="o">&lt;-</span> <span class="n">NA</span>
<span class="n">f7</span> <span class="o">&lt;-</span> <span class="n">alist</span><span class="p">(</span>
    <span class="n">y</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="n">mu</span> <span class="p">,</span> <span class="n">sigma</span> <span class="p">),</span>
    <span class="n">mu</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">x1</span> <span class="o">+</span> <span class="n">b2</span><span class="o">*</span><span class="n">x2</span><span class="p">,</span>
    <span class="n">x1</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="p">(</span> <span class="n">phi1</span> <span class="p">),</span>
    <span class="n">x2</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="p">(</span> <span class="n">phi2</span> <span class="p">),</span>
    <span class="n">a</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">100</span> <span class="p">),</span>
    <span class="n">c</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="o">~</span> <span class="n">dnorm</span><span class="p">(</span> <span class="mi">0</span>  <span class="p">,</span> <span class="mi">10</span> <span class="p">),</span>
    <span class="n">phi1</span> <span class="o">~</span> <span class="n">beta</span><span class="p">(</span> <span class="mi">1</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">phi2</span> <span class="o">~</span> <span class="n">beta</span><span class="p">(</span> <span class="mi">1</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">),</span>
    <span class="n">sigma</span> <span class="o">~</span> <span class="n">dcauchy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">m7</span> <span class="o">&lt;-</span> <span class="n">map2stan</span><span class="p">(</span> <span class="n">f7</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span> <span class="p">,</span> 
      <span class="n">constraints</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">phi1</span><span class="o">=</span><span class="s2">&quot;lower=0,upper=1&quot;</span><span class="p">,</span><span class="n">phi2</span><span class="o">=</span><span class="s2">&quot;lower=0,upper=1&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>While the unobserved values for the binary predictors are usually not of interest, they can be computed from the posterior distribution. Adding the argument <code class="docutils literal notranslate"><span class="pre">do_discrete_imputation=TRUE</span></code> instructs <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> to perform these calculations automatically. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m6</span> <span class="o">&lt;-</span> <span class="n">map2stan</span><span class="p">(</span> <span class="n">f6</span> <span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="s2">&quot;lower=0,upper=1&quot;</span><span class="p">)</span> <span class="p">,</span>
      <span class="n">do_discrete_imputation</span><span class="o">=</span><span class="n">TRUE</span> <span class="p">)</span>
<span class="n">precis</span><span class="p">(</span> <span class="n">m6</span> <span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span> <span class="p">)</span>
</pre></div>
</div>
<p>The output contains samples for each case with imputed probilities that <code class="docutils literal notranslate"><span class="pre">x</span></code> takes the value 1.</p>
<p>The algorithm works by constructing a list of mixture terms that are needed to to compute the probability of each observed <code class="docutils literal notranslate"><span class="pre">y</span></code> value. In the simplest case, with only one predictor with missing values, the implied mixture likelihood contains two terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>In the parameters of our example model <code class="docutils literal notranslate"><span class="pre">m6</span></code> above, this is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">phi</span><span class="o">*</span><span class="n">N</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
<p>It is now a simple matter to loop over cases <code class="docutils literal notranslate"><span class="pre">i</span></code> and compute the above for each. Similarly the posterior probability of that <code class="docutils literal notranslate"><span class="pre">x[i]==1</span></code> is given as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="o">|</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">phi</span><span class="o">*</span><span class="n">N</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>When only one predictor has missingness, then this is simple. What about when there are two or more? In that case, all the possible combinations of missingness have to be accounted for. For example, suppose there are two predictors, <code class="docutils literal notranslate"><span class="pre">x1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span></code>, both with missingness on case <code class="docutils literal notranslate"><span class="pre">i</span></code>. Now the implied mixture likelihood is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>There are four combinations of unobserved values, and so four terms in the mixture likelihood. When <code class="docutils literal notranslate"><span class="pre">x2</span></code> is instead observed, we can substitute the observed value into the above, and then the mixture simplifies readily to our previous two-term likelihood:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                  <span class="o">=</span> <span class="p">[</span><span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
                    <span class="o">+</span> <span class="p">[</span><span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                  <span class="o">=</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Pr</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="n">Pr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">|</span><span class="n">x1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This implies that if we loop over cases <code class="docutils literal notranslate"><span class="pre">i</span></code> and insert any observed values into the general mixture likelihood, we can compute the relevant mixture for the specific combination of missingness on each case <code class="docutils literal notranslate"><span class="pre">i</span></code>. That is what <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> does. The general mixture terms can be generated algorithmically. The code below generates a matrix of terms for <code class="docutils literal notranslate"><span class="pre">n</span></code> binary variables with missingness.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ncombinations</span> <span class="o">&lt;-</span> <span class="mi">2</span><span class="o">^</span><span class="n">n</span>
<span class="n">d</span> <span class="o">&lt;-</span> <span class="n">matrix</span><span class="p">(</span><span class="n">NA</span><span class="p">,</span><span class="n">nrow</span><span class="o">=</span><span class="n">ncombinations</span><span class="p">,</span><span class="n">ncol</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">col_var</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="p">)</span> 
    <span class="n">d</span><span class="p">[,</span><span class="n">col_var</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">rep</span><span class="p">(</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span> <span class="p">,</span> <span class="n">each</span><span class="o">=</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">col_var</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="n">length</span><span class="o">.</span><span class="n">out</span><span class="o">=</span><span class="n">ncombinations</span> <span class="p">)</span>
</pre></div>
</div>
<p>Rows of <code class="docutils literal notranslate"><span class="pre">d</span></code> contain terms, columns contain variables, and the values in each column are the corresponding values of each variable. The algorithm builds a linear model for each row in this matrix, composes the mixture likelihood as the sum of these rows, and performs proper substitutions of observed values. All calculations are done on the log scale, for precision.</p>
</div>
<div class="section" id="gaussian-process">
<h2>Gaussian process<a class="headerlink" href="#gaussian-process" title="Permalink to this headline">¶</a></h2>
<p>A basic Gaussian process can be specified with the <code class="docutils literal notranslate"><span class="pre">GPL2</span></code> distribution label. This implies a multivariate Gaussian with a covariance matrix defined by the ordinary L2 norm distance function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">k</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">eta</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">rho</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="p">)</span> <span class="o">+</span> <span class="n">ifelse</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">,</span><span class="n">sigma</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">D</span></code> is a matrix of pairwise distances. To use this convention in, for example, a spatial autocorrelation model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>library(rethinking)
data(Kline2)
d &lt;- Kline2
data(islandsDistMatrix)
d$society &lt;- 1:10
mGP &lt;- map2stan(
    alist(
        total_tools ~ dpois( mu ),
        log(mu) &lt;- a + aj[society],
        a ~ dnorm(0,10),
        aj[society] ~ GPL2( Dmat , etasq , rhosq , 0.01 ),
        etasq ~ dcauchy(0,1),
        rhosq ~ dcauchy(0,1)
    ),
    data=list(
        total_tools=d$total_tools,
        society=d$society,
        Dmat=islandsDistMatrix),
    constraints=list(
        etasq=&quot;lower=0&quot;,
        rhosq=&quot;lower=0&quot;
    ),
    warmup=1000 , iter=5000 , chains=4 )
</pre></div>
</div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">constraints</span></code> list to pass custom parameter constraints to Stan. This example is explored in more detail in the book.</p>
</div>
<div class="section" id="information-criteria">
<h2>Information criteria<a class="headerlink" href="#information-criteria" title="Permalink to this headline">¶</a></h2>
<p>Both <code class="docutils literal notranslate"><span class="pre">map</span></code> and <code class="docutils literal notranslate"><span class="pre">map2stan</span></code> provide DIC and WAIC. Well, in most cases they do. In truth, both tools are flexible enough that you can specify models for which neither DIC nor WAIC can be correctly calculated. But for ordinary GLMs and GLMMs, it works. See the R help <code class="docutils literal notranslate"><span class="pre">?WAIC</span></code>. A convenience function <code class="docutils literal notranslate"><span class="pre">compare</span></code> summarizes information criteria comparisons, including standard errors for WAIC.</p>
<p><code class="docutils literal notranslate"><span class="pre">ulam</span></code> supports WAIC calculation with the optional <code class="docutils literal notranslate"><span class="pre">log_lik=TRUE</span></code> argument, which returns the kind of log-likelihood vector needed by the <code class="docutils literal notranslate"><span class="pre">loo</span></code> package.</p>
<p><code class="docutils literal notranslate"><span class="pre">ensemble</span></code> computes <code class="docutils literal notranslate"><span class="pre">link</span></code> and <code class="docutils literal notranslate"><span class="pre">sim</span></code> output for an ensemble of models, each weighted by its Akaike weight, as computed from WAIC.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="code-issues-with-1st-edition-of-statistical-rethinking">
<h1>Code issues with 1st edition of Statistical Rethinking<a class="headerlink" href="#code-issues-with-1st-edition-of-statistical-rethinking" title="Permalink to this headline">¶</a></h1>
<p>A small change to <code class="docutils literal notranslate"><span class="pre">link</span></code> has broken two examples in the first edition of the book, in Chapter 7.</p>
<div class="section" id="r-code-7-10">
<h2>R code 7.10<a class="headerlink" href="#r-code-7-10" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>mu.Africa.mean &lt;- apply( mu.Africa , 2 , mean )
Error in apply(mu.Africa, 2, mean) : dim(X) must have a positive length</p>
</div></blockquote>
<p>This occurs because link() now returns all linear models. So mu.Africa is a list containing mu and gamma. To fix, use:</p>
<blockquote>
<div><p>mu.Africa.mean &lt;- apply( mu.Africa$mu , 2 , mean )</p>
</div></blockquote>
<p>Use a similar fix in the other apply() calls in the same section.</p>
</div>
<div class="section" id="r-code-7-17">
<h2>R code 7.17<a class="headerlink" href="#r-code-7-17" title="Permalink to this headline">¶</a></h2>
<p>Similar problem as for R code 7.10. Use mu.ruggedlo$mu in place of mu.ruggedlo.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./data/rethinking-master"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Rodolpho Macedo dos Santos<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>